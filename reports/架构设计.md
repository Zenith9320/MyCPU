# assassyn cpu

麻了，这单元测试写得太搞笑了，完全按照我自己每个单元的逻辑来，根本没有什么检测正确性的作用。还是得揉在一起调试。

# HINT

decoder 阶段就应当能直接获取真实的 rs1, rs2（从 ex_bypass_data 等中获取），这点会导致 decoder_impl 与原设计不同。

尽管 BTB 没有实现，我们（希望）现在还是有分支预测：全部返回 true，故而需要一个 branch_target 寄存器，用于存储预测的结果，方便在 ex 阶段判断是否正确、是否需要 flush.

decoder 应当能返回 rs1, rs2 的原始值（下标）（可以返回更多东西）

全局有一个 branch target 寄存器，在 MA 处可以看到其作用。

# 已实现的功能/接口:

## utils

一些通用设施。

Rs1Type: 选择哪个地方来的 rs1 值

一些 CtrlSignals: 字面意义

## bypass

传入原始的 rs1, rs2, 以及 ex/mem/wb 阶段用到的 rd，根据从后往前的顺序更新应该选用哪个模块的值

根据 ex 是否为 load/store 以及 ma 是否为 store 判断**当前**阶段需不需要 stall

## write back

ports={index, data}

如果 index 不是 0，向 regfile 写入

返回 index 和 data，作为 bypass 引脚

## memory access

ports={ctrl, alu_result}

如果是要 load，在这里进行原始数据的拿取与正确的 padding，并传给 wb/bypass

如果是 store，交给 memory user 进行处理

返回 rd, data, is_store，作为 bypass 引脚

is_store 也是 bypass 引脚。

## memory user

操控 memory 下个阶段的状态。

比如，当前 ex 阶段是 load/store，当前阶段就要做好准备：若为 load，则需要调好地址；若为 store，则也需要调好地址，方便获取原来的 byte 中的值，进而合成正确的值进行写入。

会把这些信息存入一个 register 中进行跨周期的传输。

如果不是有 memory access 的需求，调整为 if 所需要的地址。

## execution

ports={ctrl, pc, rs1, rs2, imm}

能在其中完成各种运算，大小比较等

可以得出正确的下一个指令的 pc

此阶段可能因为这个产生 flush 信号（预测错误），这会使得本周期 execution 和下一周期 decoder 和 execution 阶段的指令被作废（这也是 flush 的实际实现）

在这个阶段会需要用到 branch target 寄存器，它的作用是：1. 利用是否为 0 判断要不要 nop（predict 错误）；2. 在非 0 的情况下，告诉 fetcher 和 decoder 正确的指令位置在哪里。

完成后返回 rd 和 alu_res 作为 bypass 引脚

is_store, is_load, mem_width, rs2 作为 MemUser 引脚（下个周期使用 mem 的话，在本周期将其状态设置好）

## decoder

ports={pc, next_pc, is_stall}

decoder对instruction进行预处理，把相关信息bundle起来丢给下游

decoder_impl根据if_stall和if_flush来判断是否要把指令置成NOP，然后根据rs1和rs2的type来获取真正的rs1和rs2的值

返回ExCtrlSignals类型的ctrl_signals、pc、rs1和rs2的值以及imm传入EX

## fetcher:

ports={}

fetcher由pc_reg和last_pc_reg组成，存储本周期和上个周期的pc_addr

fetcher_impl检测EX阶段是否传入pc，即branch_target_reg是否非0，然后结合if_stall得到当前pc和预测的下一个pc，这里直接取pc+4

返回pc_addr、next_pc_addr和is_stall传给decoder
